(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* (D,Phi) + A \[Rule] A' *)

(* (D,Phi)+A[m,N] \[Rule] A[m+1,N+2] *)
(* map of indices of states when a D,Phi pair combines to make two singly occupied sites *)

(* N=0 case *)
makeHtDPhiAN0c[m_]:=Module[
{ntot1,Htsp,ntot2,ntot3,ntot4,Htsph,Htspl,Htsplh,Htsphl},
(* init basis states = 1 *)
ntot1=1;
(* N+2,m+1: Final basis states for th/tl cases:|00,m+1>,|10,m>,|01,m>,|11,m-1>; last only if m>0 *)
ntot2=If[m==0,3,4];
(*Only middle two states couple to the init state of D,Phi *)
Htsph=SparseArray[{{1,2}-> 1},{ntot1,ntot2}];
Htspl=SparseArray[{{1,3}-> 1},{ntot1,ntot2}];
{Htsph,Htspl}
];


makeHtDPhiAN0cc[m_]:=Module[
{ntot1,Htsp,ntot2,ntot3,ntot4,Htsph,Htspl,Htsplh,Htsphl},
(* init basis states = 1 *)
ntot1=1;
(* N+2,m: Final basis states for tlh case:|00,m>,|10,m-1>,|01,m-1>,|11,m-2>; last three only if m-1|2 \[GreaterEqual]0 *)
ntot3=If[m==0,1,If[m==1,3,4]];
Htsplh=SparseArray[{{1,1}-> 1},{ntot1,ntot3}];
(* N+2,m+2: Final basis states for thl{?} case:|00,m+2>,|10,m+1>,|01,m+1>,|11,m> *)
ntot4=4;
Htsphl=SparseArray[{{1,4}-> 1},{ntot1,ntot4}];
{Htsplh,Htsphl}
];



(* D&Phi sites turning to active go to the end of active list.*)
mapDPhiAc[N_,k_]:=Module[{x,ind1,ind2,listi,tab1,tab2,set1,listf,xlh,xhl,tabhl,tablh},
tab1={};tab2={};tablh={};tabhl={};
listi=comb[N,k];
Do[
set1=listi[[i]];
listf=Sort[Join[set1,{N+1}]];(* Lexicographical ordering! *)
x=c[N+2,k+1]-Sum[c[N+2-listf[[p+1]],k+1-p],{p,0,k}];
(* only when (D,Phi) \[Rule] (up,down); when they go to (down,up), add 1 in the indices, this is done when this map is used *)
AppendTo[tab1,x];(*AppendTo[tab2,x+1];*)
,{i,1,Length[listi]}];
tab1];

(*cc===> classical, cross transitions*)
mapDPhiAcc[N_,k_]:=Module[{x,ind1,ind2,listi,set1,xlh,xhl,tabhl,tablh,listf2},
tablh={};tabhl={};
listi=comb[N,k];
Do[
set1=listi[[i]];
(* Lexicographical ordering! *)
(* k=0; xlh is empty set. ??deal k\[Equal]0 case seperatly *)
xlh=c[N+2,k]-Sum[c[N+2-set1[[p+1]],k-p],{p,0,k-1}];
listf2=Sort[Join[set1,{N+1,N+2}]];
xhl=c[N+2,k+2]-Sum[c[N+2-listf2[[p+1]],k+2-p],{p,0,k+1}];
(* only when (D,Phi) \[Rule] (up,down); when they go to (down,up), add 1 in the indices, this is done when this map is used *)
AppendTo[tablh,xlh];(*AppendTo[tab2,x+1];*)
AppendTo[tabhl,xhl];(*AppendTo[tab2,x+1];*)
,{i,1,Length[listi]}];
{tablh,tabhl}];

makeHtDPhiAc[N_,m_]:=Module[
{pntr1,pntr2,Hta,Htb,ind1,ind2,ind2a,ind2b,coora,coorb,ntot1,Htsp,ntot2,Hg,ind2sub,ind1reptd,m1,m2,m3,tab1,tablh,tabhl,Htlh,Hthl,pntr3,ntot3,indhl,indlh,coorhl,coorlh,m4,pntr4,ntot4,Htsph,Htspl,Htsplh,Htsphl},

If[N==0,{Htsph,Htspl}=makeHtDPhiAN0c[m],
(* pointers for start index *)
m1=Min[m,N];m2=Min[m+1,N+2];
m3=Min[m,N+2];m4=Min[m+2,N+2];
pntr1=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
ntot1=pntr1[[-1]];
pntr2=Insert[Table[Sum[c[N+2,j],{j,0,i}],{i,0,m2}],0,1];
ntot2=pntr2[[-1]];
(* maps all sectors (up spins); Ht *)
Hta={};Htb={};Htlh={};Hthl={};
Do[
tab1=mapDPhiAc[N,k];
ind1={pntr1[[k+1]]+Table[i,{i,1,c[N,k]}]}//Transpose;
ind2=pntr2[[k+2]]+tab1; (* shift k by 1; i.e., final: k+1 *)
ind2a={ind2}//Transpose; (* th: (D,Phi) \[Rule] (up,down) *)
ind2b={ind2 +1}//Transpose; (* tl: (D,Phi) \[Rule] (down,up) *)
If[Length[ind1]>0,
coora=Join[ind1,ind2a,2];AppendTo[Hta,coora ];
coorb=Join[ind1,ind2b,2];AppendTo[Htb,coorb ];
];
,{k,0,m1}];
Htsph=SparseArray[Flatten[Hta,1]-> 1,{ntot1,ntot2}];Htspl=SparseArray[Flatten[Htb,1]-> 1,{ntot1,ntot2}];
];
{Htsph,Htspl}
];




makeHtDPhiAcc[N_,m_]:=Module[
{pntr1,pntr2,Hta,Htb,ind1,ind2,ind2a,ind2b,coora,coorb,ntot1,Htsp,ntot2,Hg,ind2sub,ind1reptd,m1,m2,m3,tab1,tablh,tabhl,Htlh,Hthl,pntr3,ntot3,indhl,indlh,coorhl,coorlh,m4,pntr4,ntot4,Htsph,Htspl,Htsplh,Htsphl},

If[N==0,{Htsplh,Htsphl}=makeHtDPhiAN0cc[m],
(* pointers for start index *)
m1=Min[m,N];(*m2=Min[m+1,N+2];*)
m3=Min[m,N+2];m4=Min[m+2,N+2];
pntr1=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
ntot1=pntr1[[-1]];
pntr3=Insert[Table[Sum[c[N+2,j],{j,0,i}],{i,0,m3}],0,1];
ntot3=pntr3[[-1]];
pntr4=Insert[Table[Sum[c[N+2,j],{j,0,i}],{i,0,m4}],0,1];
ntot4=pntr4[[-1]];
(* maps all sectors (up spins); Ht *)
Htlh={};Hthl={};
Do[
{tablh,tabhl}=mapDPhiAcc[N,k];
ind1={pntr1[[k+1]]+Table[i,{i,1,c[N,k]}]}//Transpose;
indlh={pntr3[[k+1]]+tablh}//Transpose; (* final: k *)
indhl={pntr4[[k+3]]+tabhl}//Transpose; (* final: k+2*)
If[Length[ind1]>0,
coorlh=Join[ind1,indlh,2];AppendTo[Htlh,coorlh ];
coorhl=Join[ind1,indhl,2];AppendTo[Hthl,coorhl ];
];
,{k,0,m1}];
Htsplh=SparseArray[Flatten[Htlh,1]-> 1,{ntot1,ntot3}];
Htsphl=SparseArray[Flatten[Hthl,1]-> 1,{ntot1,ntot4}];
];
{Htsplh,Htsphl}
];

