(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* 
Jh: \[CapitalPi] + A[N,m] \[Rule] \[CapitalPi] + D+ A[N-1,m-1];
Jl: \[CapitalPi] + A[N,m] \[Rule] \[CapitalPi] + D+ A[N-1,m];
For Phi case, switch Jh & Jl
*)

mapCA1[N_,k_,n_]:=Module[{x1,listi1,tab1,set1,listf,set11},
tab1={};
(* add an up site: final \[Equal]>  N,k *)
(* exclude k=0 case *)
If[k>0,
listi1=comb[N-1,k-1]; 
Do[
set1=listi1[[i]];
(* add an up site at nth position; shift n+ labels by 1 as they should be *)
set11=set1/.{q_Integer/;q>= n->q+1};(* shift by +1 all labels \[GreaterEqual] n to make room for n*)
listf=Sort[Join[set11,{n}]];
x1=c[N,k]-Sum[c[N-listf[[p+1]],k-p],{p,0,k-1}]; (* for adding an up site *)
AppendTo[tab1,x1];
,{i,1,Length[listi1]}];
];
tab1];
mapCA2[N_,k_,n_]:=Module[{x2,listi2,tab2,set2,listf,set11},
tab2={};
(* add a down site: final \[Equal]>  N,k *)
listi2=comb[N-1,k];
Do[
set2=listi2[[i]];
set11=set2/.{q_Integer/;q>= n->q+1};(* shift by +1 all labels \[GreaterEqual] n to make room for n*)
x2=c[N,k]-Sum[c[N-set2[[p+1]],k-p],{p,0,k-1}]; (* for adding a down site *)
AppendTo[tab2,x2];
,{i,1,Length[listi2]}];
tab2];


makeHtCA[N_,m_,n_]:=Module[
{pntr0,pntr1,pntr2,ntot0,ntot2,Hta,Htb,coora,coorb,ntot1,Htsph,Htspl,tab1,tab2,ind1,ind2,ind01,ind02},
(* pointers for start index *)
pntr0=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,Min[m,N]}],0,1];
pntr1=Insert[Table[Sum[c[N-1,j],{j,0,i}],{i,0,Min[m-1,N-1]}],0,1];
pntr2=Insert[Table[Sum[c[N-1,j],{j,0,i}],{i,0,Min[m,N-1]}],0,1];
ntot0=pntr0[[-1]];
ntot1=pntr1[[-1]];ntot2=pntr2[[-1]];
Hta={};Htb={};
Do[
(* indices list of initial states *)
tab1=mapCA1[N,k,n];
ind01={pntr0[[k+1]]+tab1}//Transpose;
(* indices list of final states *)
(* m-1 case: up removed *)
If[k>0&&Length[ind01]>0,
ind1={pntr1[[k]]+Table[i,{i,1,c[N-1,k-1]}]}//Transpose;
coora=Join[ind01,ind1,2];
AppendTo[Hta,coora ];
];
,{k,0,Min[m,N]}];

Do[
(* indices list of initial states *)
tab2=mapCA2[N,k,n];
ind02={pntr0[[k+1]]+tab2}//Transpose;
(* m case: down removed *)
If[Length[ind02]>0,
ind2={pntr2[[k+1]]+Table[i,{i,1,c[N-1,k]}]}//Transpose;
coorb=Join[ind02,ind2,2];
AppendTo[Htb,coorb ];
];
,{k,0,Min[m,N-1]}];

Htsph=SparseArray[Flatten[Hta,1]-> 1,{ntot0,ntot1}]; (* Jh for D *)
Htspl=SparseArray[Flatten[Htb,1]-> 1,{ntot0,ntot2}]; (* Jl for D *)
{Htsph,Htspl}
];
