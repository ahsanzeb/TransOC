(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* -------------start: vib probability distributiob ---------------*)

HgMapflip[N_,k_]:=Module[{tab,ind1,listi,tabx,sites,flipsites,set1,flip,listf,xb,xa,tabflip,tabflipx},
tab={};tabx={};tabflip={};tabflipx={};
listi=comb[N,k];
sites=Table[i,{i,1,N}];
Do[
set1=listi[[i]];
flipsites=Complement[sites,set1];
Do[
flip=flipsites[[j]];
listf=Sort[Join[set1,{flip}]];
xa=c[N,k+1]-Sum[c[N-listf[[p+1]],k+1-p],{p,0,k}];
AppendTo[tabx,xa];
AppendTo[tabflipx,flip];
,{j,1,Length[flipsites]}];
AppendTo[tab,tabx];tabx={};
AppendTo[tabflip,tabflipx];tabflipx={};
,{i,1,Length[listi]}];
{tab,tabflip}] ;


mkXb[ii_,NN_,M_]:=Module[{list,IM,xb},
xb=SparseArray[Table[{i,i+1}-> Sqrt[i],{i,1,M-1}],{M,M}];
xb += Transpose[xb];
(*xb//MatrixForm//Print;*)
list={};
IM=SparseArray[{Band[{1,1}]->1},{M,M}];
Do[
If[j==ii,AppendTo[list,xb],AppendTo[list,IM]]
,{j,1,NN}];
KroneckerProduct@@list
];

diagF=SparseArray[Band[{1,1}]->{##}]&;

(* makeHb[N=sites,M=vib_levels,m=exciton+photons], out = Hb in Full Hilnert space *)
makeHb[N_,M_,m_]:=Module[
{pntr,ind1,ind2,coora,ntot,Hg,ind2sub,m1,tab,tabflip,flips,i1,i2,iup,XB,Xb,Hb},
(* 1. make displacement operators Xb[i] = Subscript[b, i]+Subscript[b, i]^\[Dagger]*)
Do[Xb[i]=mkXb[i,N,M],{i,1,N}];
(* 2. make XB's for all basis states of electron-photon subsystem *)
(*(* starting state needs to be defined for all spin down: a zero matrix *)*)
XB[1]=SparseArray[{},{M^N,M^N}];
(* seperate case with saturated polarisation *)
m1=Min[m,N];(*If[m\[LessEqual] N,m1=m,m1=N];*)
(* pointers for start index *)
pntr=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
ntot=pntr[[-1]];
Do[
ind1=pntr[[k+1]]+Table[i,{i,1,c[N,k]}];
{tab,tabflip}=HgMapflip[N,k];
ind2=pntr[[k+2]]+tab;
Do[
ind2sub=ind2[[j]];
flips=tabflip[[j]];
Do[
{i1,i2,iup}={ind1[[j]],ind2sub[[j2]],flips[[j2]]};
(* make the new Sum[Xb's] from old by adding the flip site's Xb *)
XB[i2]=XB[i1] + Xb[iup];
,{j2,1,Length[ind2sub]}];
,{j,1,Length[ind1]}];
,{k,0,m1-1}];

(* 3. place the XB's to the correct position in full Hilbert space *)
(* blocks of dim M^N corresponding to each elec-photon basis along its diagonal*)
Hb=diagF @@ Table[XB[i],{i,1,ntot}];
Hb+=Transpose[Hb];
Hb
];

makeHgv[N_,M_,m_,gg_,dw_]:=Module[{Hg,Ivib,IM},
(*vib Identity *)
IM=SparseArray[{Band[{1,1}]->1},{M^N,M^N}];
(* Hg in elec-photon subspace *)
Hg=makeHg[N,m,gg,dw];
Hg+=Transpose[Hg];
(* Hg in full space *)
KroneckerProduct[Hg,IM]
];

makeHv[NN_,M_,m_]:=Module[{list,IM,bdb,Ielec,Hv,ntot},
bdb=SparseArray[Table[{i,i}-> i-1,{i,1,M}],{M,M}];
IM=SparseArray[{Band[{1,1}]->1},{M,M}];
Hv=SparseArray[{},{M^NN,M^NN}];
Do[
list={};
Do[
If[j==ii,AppendTo[list,bdb],AppendTo[list,IM]]
,{j,1,NN}];
Hv += KroneckerProduct@@list;
,{ii,1,NN}];
ntot=Sum[c[NN,i],{i,0,Min[m,NN]}];
Ielec=SparseArray[{Band[{1,1}]->1},{ntot,ntot}];
KroneckerProduct[Ielec,Hv ]
];



map1dn[N_,k_]:=Module[{tabb,listi},
listi=comb[N,k];
tabb={};
If[k>0,
Do[(* 1st spin is dn *)
If[FreeQ[listi[[i]],1],AppendTo[tabb,i];
];
,{i,1,Length[listi]}];
,
tabb={1};
];
tabb];

(* list of elec-phot states with site 1 down *)
mk1dnlist[N_,m_]:=Module[{m1,pntr,Htb,tab2,ind02},
(* pointers for start index *)
m1=Min[m,N];(*m2=Min[m-1,N];m3=Min[m+1,N];*)
pntr=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
Htb={};
Do[
(* indices list of initial states *)
tab2=map1dn[N,k];
ind02=pntr[[k+1]]+tab2;
If[Length[tab2]>0,
AppendTo[Htb,ind02];];
,{k,0,m1}];
Flatten[Htb,1]
];

Probvib1dn[psi_,NN_,m_,M_]:=Module[{lst1dn ,nvib,nep,psii,nvib1,prob,psi1,tot},
(* restructure psi to make the blocks of vib subspace *)
nvib=M^NN;
(*Print["Length[psi]= ",Length[psi]];*)
nep=Length[psi]/nvib;
(*Print["nep, nvib = ",nep, " ",nvib];*)
psi1 = ArrayReshape[psi,{nep,nvib}];
(*Print[psi1//Dimensions];*)
(* list of elec-phot states with site 1 down *)
lst1dn = mk1dnlist[NN,m];
(* pick these sectors and reduce vib state*)
nvib1=nvib/M;(* = M^(NN-1) states for each vib level of site 1 *)
prob=Table[0,{i,1,M}];
Do[
psii=ArrayReshape[psi1[[i]],{M,nvib1}];
prob +=Total[Abs[psii]^2,{2}];
,{i,lst1dn}];
tot=Total[prob];
If[tot!= 0,prob=prob/tot];
prob
];

GetProbnv[NN_,m_,M_,gg_,wv_,lam_,dw_]:=Module[{ntot,wvlam,H,nn,eval,evec,pr},
If[m==0||gg==0||lam==0(*||gg \[LessEqual]10*wv*lam^2*),
(* Set the output by hand in case g\[Rule]0 because othertwise results from the calc below might not be reliable due to almost entire weight in the exciton sector *)
pr=Table[0,{i,1,M}];
pr[[1]]=1;
,
ntot=Sum[c[NN,i],{i,0,Min[m,NN]}] * M^NN;
wvlam=wv*lam;
H = wv*makeHv[NN,M,m] + makeHgv[NN,M,m,gg,dw] + wvlam*makeHb[NN,M,m];
nn=Norm[Flatten[H]];
{eval,evec}=Eigensystem[H-nn*SparseArray[{Band[{1,1}]->1},{ntot,ntot}],1];
eval=eval+nn;
(*Print["N,m =",NN,",",m," ==> E_LP with vibrations = ",eval];*)
pr=Probvib1dn[evec[[1]]//Chop,NN,m,M];
];
pr
];



GetProbnvN1[m_,M_,gg_,wv_,lam_,dw_]:= Module[{IM,Ielec,Hv,Hb,Hg,H,nn,eval,evec,dims,psidn,wvlam,Exc},
(* m > 0 case only, dont call this module when m=0, use Pnv={1,0,0,0,...} instead. *)

If[m==0||gg==0||lam==0(*||gg \[LessEqual]10*wv*lam^2*),
(* Set the output by hand in case g\[Rule]0 because othertwise results from the calc below might not be reliable due to almost entire weight in the exciton sector *)
psidn=Table[0,{i,1,M}];
psidn[[1]]=1;
,
wvlam=wv*lam;
IM=SparseArray[{Band[{1,1}]->1},{M,M}];
Ielec=SparseArray[{Band[{1,1}]->1},{2,2}];
Exc=SparseArray[{{2,2}->1},{2,2}];

Hv=wv*SparseArray[Table[{i,i}-> i-1,{i,1,M}],{M,M}];
Hb=wvlam*SparseArray[Table[{i,i+1}-> Sqrt[i],{i,1,M-1}],{M,M}];
Hb += Transpose[Hb];
Hg=makeHg[1,m,gg,dw];Hg += Transpose[Hg];
(*Print["Hv = ",Hv//MatrixForm];
Print["Hb = ",Hb//MatrixForm];
Print["Hg = ",Hg//MatrixForm];
Print[KroneckerProduct[Hg,IM ]//MatrixForm];
Print[Exc//MatrixForm];*)
H=KroneckerProduct[Hg,IM ]
+KroneckerProduct[Ielec,Hv]
+KroneckerProduct[Exc,Hb ];
(*Print["H = ",H//MatrixForm];*)
dims=Dimensions[H];
nn=Norm[Flatten[H]];
{eval,evec}=Eigensystem[H-nn*SparseArray[{Band[{1,1}]->1},dims],1];
eval=eval+nn;
(*Print["evec = ",evec];*)
(* conditional state for spin down *)
dims=dims[[1]]/2;(* first half basis are for spin down*)
psidn = evec[[1,1;;dims]];
psidn=Normalize[psidn];
(* probabiltiy*)
psidn=Abs[psidn]^2;
psidn//Chop;
];
psidn
];

(* -------------end: vib probability distributiob ---------------*)

