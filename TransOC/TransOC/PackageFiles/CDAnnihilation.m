(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* \[CapitalPi] + D|Phi + A \[Rule] \[CapitalPi] + A' *)

(* Jh, Jl for contacts: 
no interference terms for the contact processes btw Jl & Jh
So, just deal with them seperately*)


(*
Jl: \[CapitalPi] + D + A[N,m] \[Rule] \[CapitalPi] + A[N+1,m];
Jh: \[CapitalPi] + D + A[N,m] \[Rule] \[CapitalPi] + A[N+1,m+1];
*)
(* D/Phi site turning to active goes to the end of active list.*)

mapCDA[N_,k_]:=Module[{x1,x2,listi,tab1,tab2,set1,listf},
tab1={};tab2={};
listi=comb[N,k];
(* (n,k): ind = c[n,k]-Sum[c[n-listi[[i,j+1]],k-j ],{j,0,k-1}] *)
Do[
set1=listi[[i]];
listf=Sort[Join[set1,{N+1}]];(* add an up site at last position *)
x1=c[N+1,k+1]-Sum[c[N+1-listf[[p+1]],k+1-p],{p,0,k}]; (* for adding an up site *)
x2=c[N+1,k]-Sum[c[N+1-set1[[p+1]],k-p],{p,0,k-1}];(* for adding a down site *)
AppendTo[tab1,x1];
AppendTo[tab2,x2];
,{i,1,Length[listi]}];
{tab1,tab2}];


makeHtCDAN0[m_]:=Module[{ntot0,ntot1,ntot2,Htsph,Htspl},
ntot0=1;(* init state, tot num of basis *)
ntot1=2;(* Jh case *)
ntot2=If[m==0,1,2];(* Jl case *)
Htsph=SparseArray[{1,2}-> 1,{ntot0,ntot1}];(* Jh *)
Htspl=SparseArray[{1,1}-> 1,{ntot0,ntot2}];(* Jl *)
{Htsph,Htspl}];

(* Seperate blocks of Jh,Jl terms; for makeHtCPhiA just switch Jh&Jl in the two blocks *)
makeHtCDA[N_,m_]:=Module[
{pntr0,pntr1,pntr2,ind0,ntot0,Hta,Htb,ind1,ind2,coora,coorb,ntot1,Htsph,Htspl,ntot2,tab1,tab2,m1},
If[N==0,{Htsph,Htspl}=makeHtCDAN0[m],
(* pointers for start index *)
m1=Min[m,N];
pntr0=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
pntr1=Insert[Table[Sum[c[N+1,j],{j,0,i}],{i,0,Min[m+1,N+1]}],0,1];
pntr2=Insert[Table[Sum[c[N+1,j],{j,0,i}],{i,0,Min[m,N+1]}],0,1];
(*pntr0=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m}],0,1];
pntr1=Insert[Table[Sum[c[N+1,j],{j,0,i}],{i,0,m+1}],0,1];
pntr2=Insert[Table[Sum[c[N+1,j],{j,0,i}],{i,0,m}],0,1];
*)ntot0=pntr0[[-1]];
ntot1=pntr1[[-1]];ntot2=pntr2[[-1]];
Hta={};Htb={};
Do[
ind0={pntr0[[k+1]]+Table[i,{i,1,c[N,k]}]}//Transpose;
{tab1,tab2}=mapCDA[N,k];
ind1=pntr1[[k+2]]+tab1; (* m+1 final excitations; shift k by 1 bcs one up spin added *)
ind2=pntr2[[k+1]]+tab2; (* m final excitations *)
ind1={ind1}//Transpose; (* Jh for D, Jl for Phi: up added *)
ind2={ind2}//Transpose;  (* Jl for D, Jh for Phi: dn added *)
If[Length[tab1]>0,coora=Join[ind0,ind1,2];AppendTo[Hta,coora ];];
If[Length[tab2]>0,coorb=Join[ind0,ind2,2];AppendTo[Htb,coorb ];];
,{k,0,m1}];
(*Print[Hta];
Print[Flatten[Hta,1]];
Print[Flatten[Htb,1]];*)
Htsph=SparseArray[Flatten[Hta,1]-> 1,{ntot0,ntot1}];(* Jh *)
Htspl=SparseArray[Flatten[Htb,1]-> 1,{ntot0,ntot2}];(* Jl *)
];
{Htsph,Htspl}
];


