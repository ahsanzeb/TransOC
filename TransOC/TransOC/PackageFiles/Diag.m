(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



HgMap[N_,k_]:=Module[{tab,ind1,listi,tabx,sites,flipsites,set1,flip,listf,xb,xa},
tab={};tabx={};
listi=comb[N,k];
sites=Table[i,{i,1,N}];
Do[
set1=listi[[i]];
flipsites=Complement[sites,set1];
Do[
flip=flipsites[[j]];
listf=Sort[Join[set1,{flip}]];
xa=c[N,k+1]-Sum[c[N-listf[[p+1]],k+1-p],{p,0,k}];
AppendTo[tabx,xa];
,{j,1,Length[flipsites]}];
AppendTo[tab,tabx];tabx={};
,{i,1,Length[listi]}];
tab] 

makeHg[N_,m_,gg_,dw_]:=Module[
{pntr,ind1,ind2,coora,ntot,Hg,ind2sub,m1,kdw,sqrt},

(* seperate case with saturated polarisation *)
m1=Min[m,N];(*If[m\[LessEqual] N,m1=m,m1=N];*)
(* pointers for start index *)
pntr=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
ntot=pntr[[-1]];
Hg=SparseArray[{},{ntot,ntot}];
Do[
ind1=pntr[[k+1]]+Table[i,{i,1,c[N,k]}];
ind2=pntr[[k+2]]+HgMap[N,k];
(*Print[HgMap[N,k]];*)
coora={};
Do[ind2sub=ind2[[j]];
Do[AppendTo[coora, {ind1[[j]],ind2sub[[j2]]}];
,{j2,1,Length[ind2sub]}];
,{j,1,Length[ind1]}];
(* caution: Sqrt[m-k]*gg contains m, not m1 *)
sqrt=Sqrt[m-k]*gg;
Hg+=SparseArray[coora-> sqrt,{ntot,ntot}];
(* add diagonal elements *)
kdw=(m-k)*dw;
If[kdw!= 0,Hg+=SparseArray[Table[{i,i}-> kdw,{i,pntr[[k+1]]+1,pntr[[k+2]]}],{ntot,ntot}]];
,{k,0,m1-1}];
Hg//Num
];

(*DiagH[N_,m_,gg_,dw_]:=Module[{Hg,eval,U,Uct,NmaxEig,dims,nn},
If[m>0,
Hg=makeHg[N,m,gg,dw];Hg+=Transpose[Hg];
(* Sort, ascending order:
ref: https://stackoverflow.com/questions/6589005/sort-eigenvalue-matrix-with-eigenvector-matrix *)
(*All eigenstates*)
{eval,U}=Transpose@SortBy[Transpose[Eigensystem[Hg]],First];
(*(*First NmaxEig eigs...;*)
NmaxEig=50;
dims=Dimensions[Hg];
NmaxEig=Min[NmaxEig,dims[[1]]];
(*If[NmaxEig\[Equal]50,Print["N,m=",N," ",m,"  NmaxEig === 50"]];*)
nn=Norm[Flatten[Hg]];
{eval,U}=Eigensystem[Hg-nn*SparseArray[{Band[{1,1}]\[Rule]1},dims],NmaxEig];
eval=eval+nn;*)
(*{eval,U}=Transpose@SortBy[Transpose[ {eval,U}],First];*)
,
(* make E&U by hand *)
eval={0.0};U={{1.0}};
];
{eval,U//Transpose}
];
*)


DiagH[N_,m_,gg_,dw_]:=Module[{Hg,eval,U,Uct,dims,nn,NmaxEigl},
If[m>0,
Hg=makeHg[N,m,gg,dw];Hg+=Transpose[Hg];
(* Sort, ascending order:
ref: https://stackoverflow.com/questions/6589005/sort-eigenvalue-matrix-with-eigenvector-matrix *)
If[NmaxEig==-1,
(*All eigenstates*)
{eval,U}=Transpose@SortBy[Transpose[Eigensystem[Hg]],First];
,
(*First NmaxEig eigs...;*)
(*NmaxEig ~ 1+C^N_m for up to the first excited degen sector *)
dims=Dimensions[Hg];
NmaxEigl=Min[NmaxEig,dims[[1]]];
(*If[NmaxEig\[Equal]50,Print["N,m=",N," ",m,"  NmaxEig === 50"]];*)
(*https://mathematica.stackexchange.com/questions/44151/find-the-eigenvector-associated-with-the-smallest-eigenvalue-not-smallest-in-ma*)
nn=Norm[Flatten[Hg]];
{eval,U}=Eigensystem[Hg-nn*SparseArray[{Band[{1,1}]->1},dims],NmaxEigl];
eval=eval+nn;
(* is this needed??? already ordered?*)
{eval,U}=Transpose@SortBy[Transpose[ {eval,U}],First];
];
,
(* make E&U by hand *)
eval={0.0};U={{1.0}};
];
{eval,U//Transpose}
];

(* 
(*First NmaxEig eigs...;*)
dims=Dimensions[H];
nn=Norm[Flatten[H]];
{eval,evec}=Eigensystem[H-nn*SparseArray[{Band[{1,1}]\[Rule]1},dims],NmaxEig];
eval=eval+nn;
*)
