(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*trajectory[Ntot_,initstate_,gg_,dw_,tpar_,Eb_,kappa_,gamma_,Er_,w0_,beta_,maxiter_,includecross_,BlockInjection_,M_,wv_,lambda_,AlwaysLP_,VibAssis_]*)


CalcTrajectory[Ntot_,m0_,gg_,maxiter_,
Ds0_,Phis0_,
tpar_,kappa_,gamma_,
dw_,Eb_,Er_,w0_,beta_,
includecross_,BlockInjection_,AlwaysLP_,
VibAssis_,M_,wv_,lambda_,printmem_,fullout_,staylow_]:=Module[{UNm,UNp1mp1,UNm1mm1,UNp1m,UNm1m,HtDA,RDA,HtPhiA,RPhiA,HtDPhiA,UNp2mp1,RDPhiA,HtDPhiAinv,UNm2mm1,RDPhiAinv,HtCDAh,HtCDAl,RCDAh,RCDAl,HtCAh,HtCAl,RCAh,RCAl,Es,
DhopsR,DhopsL,PhihopsR,PhihopsL,DPhiR,DPhiL,
CDhopsR,CDhopsL,CPhihopsR,CPhihopsL,Apairs,CAR,CAL,Cproc,CDAproc,
RDAM,RPhiAM,RDPhiAM,RDPhiAinvM,RCDAhM,RCDAlM,RCAhM,RCAlM,n,Ds,Phis,m,ASites,
ENm,ENp1mp1,ENm1mm1,ENp1m,ENm1m,ENp2mp1,ENm2mm1,Elevels,times,t,dt,R,ldr,ldl,lpr,lpl,
lApairs,si1,si2,sapos,lcdr,lcdl,lcpr,lcpl,lcdaproc,
lcar,lcal,CAproc,lcAp,r1,r1b,r2,r2b,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,
r1z,r1bz,r2z,r2bz,r3z,r4z,r5x,r6x,x1,x2,r9xh,r9xl,r10xh,r10xl,r11xh,r11xl,r12xh,r12xl,
r9i,r10i,r11i,r12i,rcd,rcp,rcdi,rcpi,r14z,
HtDAR,HtDAL,RDAR,RDAL,HtPhiAR,RPhiAR,HtPhiAL,RPhiAL,
HtApairs,ENmm1,UNmm1,RkappaM ,Rkappa,Rgamma,rates,totrates,
ltotr,slist,u,eta,wj,process,lp,whichstates,pos,apos,rate,
ldpr,ldpl,nlevels,Rlist,degen,whichsec,psif,i1,i2,xtot,Dsvst,Phisvst,mvst,Neig,istate,psi,
ldpa,NN,p1,p2,ITER,m1,Einit,HtApaira,HtApairb,out2,tlh,thl,th,tl,tpard,tparp,Htsph,Htspl,Htsplh,Htsphl,RDPhiAh,RDPhiAl,RDPhiAhl,RDPhiAlh,ENp2m,UNp2m,ENp2mp2,UNp2mp2,rr,ENmp1,UNmp1,logkg,logNmm1,ws,wc,U,ratef,dN,dm,RCAlR,RCAlL,RCAhR,RCAhL,r,rz,HtDAc,HtDAclh,HtDAchl,rlist,ii,saposOrder,t1,t2,ts78,rrAinv,HtApairlh,HtApairhl,rrcdal,rrcdah,rrcalr,rrcahr,rrcall,rrcahl,j,HtCAhL,HtCAlL,JhR,JlR,JhL,JlL,fr1,fr2,fr3,fr4,fl1,fl2,fl3,fl4,pf,HtCAhR,HtCAlR,EBL,HBL,fl4v,fr4v,thops,Ebr,Ebl,charge9to24,dCharge},


Amplitudes[wj_,ws_,wc_]:=Which[
wj==1,RDAR[ws,wc],
wj==2,RDAL[ws,wc],
wj==3,RPhiAR[ws,wc],
wj==4,RPhiAL[ws,wc],
wj==5||wj==6,RDPhiA[wc],
wj==7,RDPhiAinv[ws,wc],
wj==8,If[wc==1,RDPhiAinv[ws,2],If[wc==2,RDPhiAinv[ws,1],RDPhiAinv[ws,wc]]],
MemberQ[{9,11,13,15},wj],RCDAl,
MemberQ[{10,12,14,16},wj],RCDAh,
MemberQ[{17,18},wj],RCAlR,
MemberQ[{19,20},wj],RCAhR,
MemberQ[{21,22},wj],RCAlL,
MemberQ[{23,24},wj],RCAhL,
wj==25,Rkappa,
wj==26,Rgamma[ws]
];

RatesWjWcWs[wj_,ws_,wc_]:=Which[
MemberQ[{1,2,3,4,7,8},wj],rz[wj][ws,wc],
MemberQ[{5,6},wj],rz[wj][wc],
wj==26,rz[wj][ws],
MemberQ[{9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25},wj],rz[wj]
];

{th,tl,tlh,thl,JhR,JlR,JhL,JlL}=tpar;
thops={
{th,tl,tlh,thl},
{th,tl,tlh,thl},
{tl,th,tlh,thl},
{tl,th,tlh,thl},
{th,tl,tlh,thl},
{th,tl,tlh,thl},
{th,tl,tlh,thl},
{th,tl,tlh,thl},
{JlR},{JhR},
{JlL},{JhL},
{JhR},{JlR},
{JhL},{JlL},
{JlR},{JhR},
{JhR},{JlR},
{JlL},{JhL},
{JhL},{JlL},
{kappa},{gamma}
};

(* Block injecton... ideally should also minimise computation of corresponding transition amplitudes...*)
{EBL,HBL}=BlockInjection;
(* jump # 16,21 prob\[Rule]0*)
If[EBL==True,thops[[16,1]]=0;thops[[21,1]]=0;];
(* jump # 10,18 prob\[Rule]0*)
If[HBL,thops[[10,1]]=0;thops[[18,1]]=0;];

VibOccupHomo[NN_,m_]:=VibOccupHomo[NN,m]=Module[{pr},
pr=Table[0,{nv,1,M}];pr[[1]]=1;
If[NN>0,
If[NN==1,
pr=GetProbnvN1[m,M,gg,wv,lambda,dw],
pr=GetProbnv[NN,m,M,gg,wv,lambda,dw]
];
];
pr
];

penalty[dE_,pr_]:=Module[{prob},
If[Length[pr]>0,
prob=Sum[pr[[nv+1]]*If[dE-nv*wv<0,1,Exp[-(dE-nv*wv)*beta]]   ,{nv,0,M-1}];
,prob=If[dE<0,1,Exp[-dE*beta]]
];
(*Chop[prob,10^-30]*)
(* to avoid getting complex number when prob is too small ~ 10^-100s 
Chop is more accureate choice but it can kill all the rates and create a trap! *)
Re[prob]
];

{Ebl,Ebr}=Eb;(* Right and left contact energy barriers*)
DCQ=DEQCsum[w0,Ebr,Ebl,Er];(* classical + quantum changes*)

Rates[wj_,ws_,wc_]:=Module[{res,q1,q2,deg,nsec,Q,X,Esec,indx,sgn,tt,amp,Dm,pr},
If[MemberQ[{3,4},wc]&&includecross ==False,
res={0};
,
amp=Amplitudes[wj,ws,wc];
If[Length[amp]==0,
res={0},
(*{nlevels,Es,deg}=sec;*)
(*sec=SECs[EUinds[[j,1]]];*)
indx=EUinds[[wj,wc]];
{nsec,Esec,deg}=sectors[Es[indx]];
(* classical changes + quantum reference changes*)
Esec +=DCQ[[wj,wc]];
Esec-=Einit; (* get change in energy for all transitions/ final sectors*)

pr={};
If[VibAssis&&wc==4&&MemberQ[{3,4,7,8},wj],
pr=VibOccupHomo[NN,m];
];
tt=thops[[wj,wc]];
res={};
Do[
q1=deg[[i]];q2=deg[[i+1]];
Q=tt*Norm[amp[[q1+1;;q2]]]^2*penalty[Esec[[i]],pr];
AppendTo[res,Q];
,{i,1,nsec}];
];
];
res
];

(* choose final state and sets Einit*)
ChooseFinalState[wj_,ws_,wc_]:=Module[
{ind,Ef,Uf,coeff,Einit0,psif0},
ind=EUinds[[wj,wc]];
Ef=Es[ind];Uf=U[ind];
Einit=Ef[[1]]; (* set Einit for next iteration *)
If[AlwaysLP,
Einit0=Ef[[1]];
psif0=Uf[[All,1]],
coeff=Amplitudes[wj,ws,wc];
{Einit0,psif0}=SelectFinalState[Ef,Uf,coeff,RatesWjWcWs[wj,ws,wc]]
];
{Einit0,psif0}
];

(* beta, Erbeta: global variable to avaoid in arg of Rates *)

{Ds,Phis,m}={Ds0,Phis0,m0};(*initstate;*)

(* \[CapitalDelta]Q *)
charge9to24={1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1};
dCharge=Join[Table[0,{i,1,8}],charge9to24,{0,0}];

(* Excitations added or lost due to Homo-Lumo or Lumo-Homo hops? *)
Zener[wj_,wc_]:=Module[{zq},
zq=0;
If[wj<=8,
If[wc==3,zq=-1];
If[wc==4,zq=1]
];
zq
];

(*in this order, EhopsR,EhopsL,EinjR,EinjL,EextR,EextL,HinjR,HinjL,HextR,HextL*)
RateTypeInds={{1,4,5,8},{2,3,6,7},{14,17},{16,21},{9,20},{11,24},{10,18},{12,22},{13,19},{15,23}};


NmaxEig=-1;
t=0;times={0};out2={};
Dsvst={Ds};Phisvst={Phis};mvst={m};
ITER=0;
While[ITER<maxiter(*t<tmax*),
If[debug,
Print["*************** ITERATION # ",ITER];
Print["N = "<>ToString[NN]<>", m= "<>ToString[m],"; last wj,wc=",{wj,wc}];
];
(* starting list of active sites *)
ASites=Complement[Table[i,{i,1,Ntot}],Ds,Phis];
If[ITER==0,
NN=Length[ASites];
If[debug,
Print["Initial variables: "];
Print["N,m: ",{NN,m}];
Print["Ds: ",Ds];
Print["\[Phi]s: ",Phis];
];
];

If[staylow,NmaxEig=Sum[c[NN,mm],{mm,0,Min[4,Min[m,NN]]}]];

(* m,NN state *)
(*{ENm,UNm}=DiagH[NN,m,gg];*)
{Es[1],U[1]}=DiagH[NN,m,gg,dw];
(*secNm=sectors[ENm];*)
(*Print["ENm: ",ENm];*)

(* start with the lowest eigenstate*)
If[ITER==0,
psi=U[1][[All,1]];
(*psi=SelectFinalState[Es[1],U[1],Table[RandomReal[{0,1}],{i,1,Length[Es[1]]}]];
*)Einit=Es[1][[1]];
];

(*Print["ASites: ",ASites," NN: ",NN];*)


ITER+=1;

(*Print["Before: MemoryInUse (MB)",MemoryInUse[]/10^6//IntegerPart];*)
ClearSystemCache[];
(*Print["After: MemoryInUse (MB)",MemoryInUse[]/10^6//IntegerPart];*)


(*getrates*)
(* get Ht.Ufinal matrices for rates *)

(* site indices for various processes can occur; no. of ways = lengths of out arrays *)
{DhopsR,DhopsL,PhihopsR,PhihopsL,DPhiR,DPhiL,
CDhopsR,CDhopsL,CPhihopsR,CPhihopsL,Apairs,CAR,CAL}=OneDLatticeWays[Ntot,Ds,Phis];


(*Print["ways: ",{DhopsR,DhopsL,PhihopsR,PhihopsL,DPhiR,DPhiL,
CDhopsR,CDhopsL,CPhihopsR,CPhihopsL,Apairs,CAR,CAL}];*)
If[debug,Print["ways: ",{DhopsR,DhopsL,PhihopsR,PhihopsL,DPhiR,DPhiL,
CDhopsR,CDhopsL,CPhihopsR,CPhihopsL,Apairs,CAR,CAL}]];

(*Bulk Processes*)
(*D+A\[Rule] D+A*)
(*If[Length[DhopsR]>0||Length[DhopsL]>0,
RDAM=mkHtDA[NN,m,th,tl].Transpose[UNm];
Nstates[[1]]= Dimensions[RDAM][[2]];
];*)

If[debug,Print["----------- rates starting-------------"];];

(* get rates for current state psi *)
(*Do[r[j]=0;rlist[j]={},{j,1,26}];*)
(*Clear and initiate as definitions works*)
Clear[r,rz,rlist];
r[j_]=0;rlist[j_]={};
rz[j_][i_,ii_]=0;rz[j_][jj_]=0;

Clear[RDAR,RDAL,RPhiAR,RPhiAL,RDPhiA,RDPhiAinv,RCDAl,RCDAh,RCAlR,RCAhR,RCAlL,RCAhL,Rkappa,Rgamma];
RDAR[x_,y_]=0;RDAL[x_,y_]=0;
RPhiAR[x_,y_]=0;RPhiAL[x_,y_]=0;
RDPhiA[x_]=0;RDPhiAinv[x_,y_]=0;
RCDAl=0;RCDAh=0;
RCAlR=0;RCAhR=0;
RCAlL=0;RCAhL=0;
Rkappa=0;Rgamma[x_]=0;



ldr=Length[DhopsR];
ldl=Length[DhopsL];
lpr=Length[PhihopsR];
lpl=Length[PhihopsL];

logNmm1=(ldr+ldl+lpr+lpl)>0&&includecross;
logkg=kappa+gamma>0;

If[logNmm1||logkg,(*{ENmm1,UNmm1}*){Es[2],U[2]}=DiagH[NN,m-1,gg,dw]];
If[logNmm1,
(*{ENmp1,UNmp1}*){Es[3],U[3]}=DiagH[NN,m+1,gg,dw]];

(* Lumo to homo hop requires minimum of m=1 for jump 1-4. 
Instead of applying this condition on calculation of U and Ht,
the dimensions of corresponding empty Ht are set to make it compatible for dot product with U *)

If[debug,Print["------j=1"];];
(*D+A\[Rule] D+A*)
j=1;
Do[
(*Print["calc HtDAR[i], i= ",i];*)
n=Position[ASites,DhopsR[[i]] +1] [[1,1]]; (* active site on right of D *)
HtDAc=mkHtDAc[NN,m,n];(* ={Htsph,Htspl,Htsplh,Htsphl}*)
Do[RDAR[i,ii]=psi.HtDAc[[ii]].U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];(*Rates[RDAR[i,ii],+1,SECs[EUinds[[j,ii]]],Einit];*)
r[j]+=Total[rz[j][i,ii]];
,{ii,1,2}];
If[includecross,
{HtDAclh,HtDAchl}=mkHtDAcc[NN,m,n];
ii=3;
(*Print["psi.HtDAclh.U[EUinds[[j,ii]]====> "];
Print[Dimensions[psi]];
Print[Dimensions[HtDAclh],Dimensions[HtDAchl]];
Print[Dimensions[U[EUinds[[1,3]]]],Dimensions[U[EUinds[[1,4]]]]];*)
RDAR[i,ii]=psi.HtDAclh.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
ii=4;
RDAR[i,ii]=psi.HtDAchl.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
Do[AppendTo[rlist[j],Total[rz[j][i,ii]]],{ii,1,4}];
];
,{i,1,ldr}];

(*Print["------j=2"];*)
If[debug,Print["----------- rates 2-------------"];];
j=2;
Do[
n=Position[ASites,DhopsL[[i]] -1] [[1,1]]; (* active site on right of D *)
HtDAc=mkHtDAc[NN,m,n];(* ={Htsph,Htspl,Htsplh,Htsphl}*)
Do[RDAL[i,ii]=psi.HtDAc[[ii]].U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
,{ii,1,2}];

If[includecross,
{HtDAclh,HtDAchl}=mkHtDAcc[NN,m,n];
ii=3;
RDAL[i,ii]=psi.HtDAclh.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
ii=4;
RDAL[i,ii]=psi.HtDAchl.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
];
Do[AppendTo[rlist[j],Total[rz[j][i,ii]]],{ii,1,4}];
,{i,1,ldl}];

If[debug,Print["----------- rates 3 right -------------"];];
(*Phi+A\[Rule] Phi+A*)
(*If[Length[PhihopsR]>0||Length[PhihopsL]>0,
RPhiAM=mkHtPhiA[NN,m,th,tl].Transpose[UNm];
];*)
(*Print["------j=3"];*)
(*lpr=Length[PhihopsR];*)
(*Print["PhihopsR: ",PhihopsR];*)
j=3;
Do[
n=Position[ASites,PhihopsR[[i]] +1] [[1,1]]; (* active site on right of D *)
HtDAc=Reverse[mkHtDAc[NN,m,n]];(* ={Htsph,Htspl,Htsplh,Htsphl}*)
Do[RPhiAR[i,ii]=psi.HtDAc[[ii]].U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
,{ii,1,2}];
If[includecross,
{HtDAclh,HtDAchl}=mkHtDAcc[NN,m,n];
ii=3;
(*Print["j3,ii=4;Dims: psi,HtDAchl,U[EUinds[[j,ii]]]: ",Dimensions[psi]," ",Dimensions[HtDAclh]," ",Dimensions[U[EUinds[[j,ii]]]]];
Print["EUinds[[j,ii]]= ",EUinds[[j,ii]]];*)
RPhiAR[i,ii]=psi.HtDAclh.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
ii=4;
(*Print["j3,ii=4;Dims: psi,HtDAchl,U[EUinds[[j,ii]]]: ",Dimensions[psi]," ",Dimensions[HtDAchl]," ",Dimensions[U[EUinds[[j,ii]]]]];
Print["EUinds[[j,ii]]= ",EUinds[[j,ii]]];*)
RPhiAR[i,ii]=psi.HtDAchl.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
];
Do[AppendTo[rlist[j],Total[rz[j][i,ii]]],{ii,1,4}];
,{i,1,lpr}];

(*Print["------j=4"];*)
If[debug,Print["----------- rates 3 left-------------"];];

(*lpl=Length[PhihopsL];*)
(*Print["PhihopsR: ",PhihopsR];*)
j=4;
Do[
n=Position[ASites,PhihopsL[[i]] -1] [[1,1]]; (* active site on right of D *)
HtDAc=Reverse[mkHtDAc[NN,m,n]];(* ={Htsph,Htspl,Htsplh,Htsphl}*)
Do[RPhiAL[i,ii]=psi.HtDAc[[ii]].U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
,{ii,1,2}];

(*Print["----------- rates 3y-------------"];*)

If[includecross,
{HtDAclh,HtDAchl}=mkHtDAcc[NN,m,n];
ii=3;

(*Print["N,m = ",NN," ",m];
Print["ii=4;Dims: psi,HtDAchl,U[EUinds[[j,ii]]]: ",Dimensions[psi]," ",Dimensions[HtDAclh]," ",Dimensions[U[EUinds[[j,ii]]]]];
Print["EUinds[[j,ii]]= ",EUinds[[j,ii]]];*)
RPhiAL[i,ii]=psi.HtDAclh.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
ii=4;
(*Print["ii=4;Dims: psi,HtDAchl,U[EUinds[[j,ii]]]: ",Dimensions[psi]," ",Dimensions[HtDAchl]," ",Dimensions[U[EUinds[[j,ii]]]]];
Print["EUinds[[j,ii]]= ",EUinds[[j,ii]]];*)
RPhiAL[i,ii]=psi.HtDAchl.U[EUinds[[j,ii]]];
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
];
Do[AppendTo[rlist[j],Total[rz[j][i,ii]]],{ii,1,4}];
,{i,1,lpl}];

(*Print["----------- rates 3 z-------------"];*)
(* (D,Phi) + A \[Rule] A' *)
(*{Htsph,Htspl,Htsplh,Htsphl}*)
ldpr=Length[DPhiR];
ldpl=Length[DPhiL];
ldpa=ldpr+ldpl;

If[debug,Print["------j=5"];];

If[ldpa>0,
(*{ENp2mp1,UNp2mp1}*){Es[4],U[4]}=DiagH[NN+2,m+1,gg,dw];
{Htsph,Htspl}=makeHtDPhiAc[NN,m];

RDPhiA[1]=psi.Htsph.U[4];
RDPhiA[2]=psi.Htspl.U[4];

If[includecross,
{Htsplh,Htsphl}=makeHtDPhiAcc[NN,m];
(* {ENp2m,UNp2m}*){Es[5],U[5]}=DiagH[NN+2,m,gg,dw];
RDPhiA[3]=psi.Htsplh.U[5];
 (*{ENp2mp2,UNp2mp2}*){Es[6],U[6]}=DiagH[NN+2,m+2,gg,dw];
RDPhiA[4]=psi.Htsphl.U[6];
];

(*rr=Table[Norm[RDPhiA[i]]^2,{i,1,4}];*)
(*break into D,Phi and Phi,D pairs; diff sgn => diff rates *)
j=5;
If[ldpr>0,
Do[
rz[j][jj]=Rates[j,0,jj];
r[j]+=Total[rz[j][jj]]*ldpr;
,{jj,1,4}];

Do[AppendTo[rlist[j],Total[rz[j][ii]]],{ii,1,4}]
(*Does not matter if dont multiply ldpl with Total[rz[j][ii]]] for rlist[j] here as it will not change relative prob of the channels if this j is already selected on basis of r[j]*)
];
j=6;
If[ldpl>0,
Do[
rz[j][jj]=Rates[j,0,jj];
r[j]+=Total[rz[j][jj]]*ldpl;
,{jj,1,4}];
Do[AppendTo[rlist[j],Total[rz[j][ii]]],{ii,1,4}];
];
];

If[debug,Print["------j=6"];];

(*Print["----------- rates 4-------------"];*)
(* inv processes: A\[Rule](D,Phi)+A *)
lApairs=Length[Apairs];
(* If m\[Equal]0, no D,Phi pair generation possible, so set lApairs=0*)

If[lApairs>0,
(*conditions on pf[[7;;8,All]] can avoid unnecessary calculations of Hts/Us and amplitudes;
If[lApairs>0 and all rates>0,
m\[GreaterEqual] 1 and th,tl >0, and similarly m\[GreaterEqual] 2 and tlh>0 etc...*)  
If[m>=1,
(*{ENm2mm1,UNm2mm1}*){Es[7],U[7]}=DiagH[NN-2,m-1,gg,dw];
];

If[includecross,
If[m>=2,
(*{ENm2mm2,UNm2mm2}*){Es[8],U[8]}=DiagH[NN-2,m-2,gg,dw];
];
(*If[m\[GreaterEqual]0,*)
(*{ENm2m,UNm2m}*){Es[9],U[9]}=DiagH[NN-2,m,gg,dw];
];

saposOrder={};
Do[
(*Print["calc HtApairs[i], i= ",i];*)
si1=Apairs[[i]];(* site indexes in lattice *)
{p1,p2}={Position[ASites,si1][[1,1]],Position[ASites,si1+1][[1,1]]};
(*sapos in order, assume abeling from left to right*)
sapos={Min[p1,p2],Max[p1,p2]};
(*If[sapos\[Equal]{p1,p2},AppendTo[saposOrder,True],AppendTo[saposOrder,False];];*)
(*If[saposOrder[[i]],t1=th;t2=tl,t1=tl;t2=th];*)

(*If[sapos\[Equal]{p1,p2},t1=th;t2=tl,t1=tl;t2=th];
ts78[7]={t1,t2,tlh,thl};ts78[8]={t2,t1,tlh,thl};
*)
(* initialise total rates for four channels *)
(*Do[rrAinv[ii]=0,{ii,1,4}];*)

If[m>=1,
If[sapos=={p1,p2},
{HtApaira[i],HtApairb[i]}=makeHtApairsc[NN,m,sapos],
{HtApairb[i],HtApaira[i]}=makeHtApairsc[NN,m,sapos]
];

(* saposOrder: True ===> th&tl with Hta,Htb give D,Phi; else give Phi,D*)
RDPhiAinv[i,1]=psi.HtApaira[i].U[7];
RDPhiAinv[i,2]=psi.HtApairb[i].U[7];
];

If[debug,Print[ " ----j=7,8"];];

If[includecross,
If[m>=2, 
HtApairlh=makeHtApairsclh[NN,m,sapos];
RDPhiAinv[i,3]=psi.HtApairlh.U[8]
];
HtApairhl=makeHtApairschl[NN,m,sapos];
RDPhiAinv[i,4]=psi.HtApairhl.U[9]
];

(* th,tl,tlh or thl, include in pf for j=7,8, and others if needed *)
(* j=7,8 *)
Do[
Do[
rz[j][i,ii]=Rates[j,i,ii];
r[j]+=Total[rz[j][i,ii]];
,{ii,1,4}];
Do[AppendTo[rlist[j],Total[rz[j][i,ii]]],{ii,1,4}];
,{j,7,8}];

,{i,1,lApairs}]
];

(*Print["----------- rates 5 -------------"];*) 
(*Contact Processes*)
(*Jh: \[CapitalPi] + D + A[NN,m] \[Rule] \[CapitalPi] + A[NN+1,m+1];Jl: \[CapitalPi] + D + A[NN,m] \[Rule] \[CapitalPi] + A[NN+1,m];*)
(*CDAproc=Join[CDhopsR,CDhopsL,CPhihopsR,CPhihopsL];
lcdaproc=Length[CDAproc];*)

{rrcdal,rrcdah,rrcalr,rrcahr,rrcall,rrcahl}={0,0,0,0,0,0};

lcdr=Length[CDhopsR];lcdl=Length[CDhopsL];
lcpr=Length[CPhihopsR];lcpl=Length[CPhihopsL];
lcdaproc=lcdr+lcdl+lcpr+lcpl;

If[lcdaproc>0,
(*Print["calc RCDAhM, RCDAlM ... "];*)
{HtCDAh,HtCDAl}=makeHtCDA[NN,m];
(*{ENp1mp1,UNp1mp1}*){Es[10],U[10]}=DiagH[NN+1,m+1,gg,dw];
(*secNp1mp1=sectors[ENp1mp1];*)
(*{ENp1m,UNp1m}*){Es[11],U[11]}=DiagH[NN+1,m,gg,dw];
(*secNp1m=sectors[ENp1m];*)
RCDAh=psi.HtCDAh.U[10];
RCDAl=psi.HtCDAl.U[11];
(*rrcdal=Norm[RCDAl]^2;
rrcdah=Norm[RCDAh]^2;*)

If[lcdr>0,
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,9,10}];
];
If[lcdl>0,
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,11,12}]
];
If[lcpr>0,
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,13,14}]
];
If[lcpl>0,
(* channel m *)
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,15,16}]
];
];

(*Print["----------- rates 6-------------"];*)
(* Jh: \[CapitalPi] + A[NN,m] \[Rule] \[CapitalPi] + D+ A[NN-1,m-1];Jl: \[CapitalPi] + A[NN,m] \[Rule] \[CapitalPi] + D+ A[NN-1,m];For Phi case, switch Jh & Jl*)
lcar=Length[CAR];lcal=Length[CAL];
CAproc=Join[CAR,CAL];lcAp=Length[CAproc];
If[lcAp>0,
(* only if m is not 0 *)
If[m>0,
(*{ENm1mm1,UNm1mm1}*){Es[12],U[12]}=DiagH[NN-1,m-1,gg,dw];
];
(*{ENm1m,UNm1m}*){Es[13],U[13]}=DiagH[NN-1,m,gg,dw];

If[lcar>0,
n=Position[ASites,Ntot][[1,1]];
{HtCAhR,HtCAlR}=makeHtCA[NN,m,n];
(* m channels, j=16,17*)
RCAlR=psi.HtCAlR.U[13];
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,17,18}];
(* m-1 channels, j=18,19*)
If[m>0,
RCAhR=psi.HtCAhR.U[12];
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,19,20}];
];
];

If[lcal>0,
n=Position[ASites,1][[1,1]];
{HtCAhL,HtCAlL}=makeHtCA[NN,m,n];
(* m channels, j=16,17*)
RCAlL=psi.HtCAlL.U[13];
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,21,22}];
(* m-1 channels, j=18,19*)
If[m>0,
RCAhL=psi.HtCAhL.U[12];
Do[
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
,{j,23,24}];
];
];

];

(*Print["----------- rates 7-------------"];*)

(* kappa and gamma *)
If[(kappa>0||gamma>0)&&m>0,
(*{ENmm1,UNmm1}=DiagH[NN,m-1,gg];
secNmm1=sectors[ENmm1];
*)(* kappa *)
Rkappa=psi.HtKappa[NN,m].U[2];
j=25;
(*rz[j]=Norm[Rkappa]^2;(*Rates[Rkappa,0,secNmm1,Einit];*)
r[j]+=rz[j];*)
rz[j]=Rates[j,0,1];
r[j]+=Total[rz[j]];
(* gamma *)
j=26;
Do[
Rgamma[i] = psi.HtGamma[NN,m,i].U[2];
(*rz[j][i]=Norm[Rgamma[i]]^2;(*Rates[Rgamma[i],0,secNmm1,Einit];*)
r[j]+=rz[j][i];*)
rz[j][i]=Rates[j,i,1];
r[j]+=Total[rz[j][i]];
Do[AppendTo[rlist[j],Total[rz[j][i]]],{ii,1,4}];
,{i,1,NN}];
];


(*Print["----------- rates 8-------------"];*)

(* total rate etc; add kappa/gamma ! *)
(*Print["calc: r[j]: ",Table[r[j],{j,1,26}]];*)
totrates=Table[r[j],{j,1,26}];
(*Print["totrates: ",totrates];*)
wj=WhichSite[totrates];
R= Total[totrates];
(* time increment *)
u=RandomReal[{10^-10,1}];
dt = (1/R )*Log[1/u]; (* or just average value= 1/R ? dev \[Sigma]=1/R *)
t += dt;
AppendTo[times,t];

If[debug,Print["----------- rates done -------------"];];

If[debug,Print["rlist: ",Table[rlist[j],{j,1,26}]//Chop];];

wc=1;
If[wj<= 8,(*Print["wj = ",wj," rlist[wj]: ",rlist[wj]];*){ws,wc}=WhichSiteChannel[rlist[wj]],
If[wj==26,(*Print["---- wj=26"];*)ws=WhichSite[rlist[wj]]]
];

If[Not[includecross]&&wc>2,Print[" Someting wrong... includecross=False, still wc>2; wc=",wc]; Abort[];
];


If[debug,
Print["totrates: ",totrates];
Print["wj: ",wj];];


(* change state *)
{Einit,psi}=ChooseFinalState[wj,ws,wc];
(* change N and m*)
{dN,dm}=ListdNm[[EUinds[[wj,wc]]]];
NN += dN; m +=dm;


(*Print["----------- psi updated -----------"];*)

(* which final state/degenerate sector?: whichsec? *)
If[wj==1,
(* update Ds, positions of D sites *)
pos=DhopsR[[ws]];
apos=pos+1;
Ds=Ds/.{pos-> apos};
ASites=ASites/.{apos-> pos};
];

If[wj==2,
(* update Ds, positions of D sites *)
pos=DhopsL[[ws]];
apos=pos-1;
Ds=Ds/.{pos-> apos};
ASites=ASites/.{apos-> pos};
];

If[wj==3,
(* update Ds, positions of D sites *)
pos=PhihopsR[[ws]];
apos=pos+1;
Phis=Phis/.{pos-> apos};
ASites=ASites/.{apos-> pos};
];

If[wj==4,
(* update Ds, positions of D sites *)
pos=PhihopsL[[ws]];
apos=pos-1;
Phis=Phis/.{pos-> apos};
ASites=ASites/.{apos-> pos};
];


(* DPhiR and DPhiL cases; j=5,6 *)
If[wj==5,
ws=RandomInteger[{1,ldpr}];
(* update Ds & Phis*)
pos=DPhiR[[ws]];
Ds=Dropp[Ds,pos];(*Ds=Drop[Ds,{Position[Ds,pos][[1,1]]}];*)
Phis=Dropp[Phis,pos+1];
AppendTo[ASites,pos];(* first D then Phi sites *)
AppendTo[ASites,pos+1];
];

If[wj==6,
ws=RandomInteger[{1,ldpl}];
(* update Ds & Phis*)
pos=DPhiL[[ws]];
Ds=Dropp[Ds,pos];
Phis=Dropp[Phis,pos-1];
AppendTo[ASites,pos];(* first D then Phi sites *)
AppendTo[ASites,pos-1];
];

(* Apairs cases; DPhi,PhiD \[Equal]> j 7,8*)
If[wj==7,
(* update Ds and Phis *)
pos=Apairs[[ws]];
AppendTo[Ds,pos];AppendTo[Phis,pos+1];
ASites=Dropp[ASites,pos];ASites=Dropp[ASites,pos+1];
];

If[wj==8,
(* update Ds and Phis *)
pos=Apairs[[ws]];
AppendTo[Ds,pos+1];AppendTo[Phis,pos];
ASites=Dropp[ASites,pos];ASites=Dropp[ASites,pos+1];
];


If[wj==9||wj==11,
If[wj==9,
Ds=Dropp[Ds,Ntot];AppendTo[ASites,Ntot];
,Ds=Dropp[Ds,1];AppendTo[ASites,1];];
];
 If[wj==10||wj==12,
If[wj==10,
Ds=Dropp[Ds,Ntot];AppendTo[ASites,Ntot];
,Ds=Dropp[Ds,1];AppendTo[ASites,1]];
];


If[wj==13||wj==15,
If[wj==13,
Phis=Dropp[Phis,Ntot];AppendTo[ASites,Ntot];
,Phis=Dropp[Phis,1];AppendTo[ASites,1]];
];
If[wj==14||wj==16,
If[wj==14,
Phis=Dropp[Phis,Ntot];AppendTo[ASites,Ntot];
,Phis=Dropp[Phis,1];AppendTo[ASites,1];];
];


If[wj==17||wj==18,
If[wj==17,AppendTo[Ds,Ntot],AppendTo[Phis,Ntot]];
ASites=Dropp[ASites,Ntot];
];
If[wj==19||wj==20,
If[wj==19,AppendTo[Ds,Ntot],AppendTo[Phis,Ntot]];
ASites=Dropp[ASites,Ntot];
];


If[wj==21||wj==22,
If[wj==21,AppendTo[Ds,1],AppendTo[Phis,1]];
ASites=Dropp[ASites,1];
];
If[wj==23||wj==24,
If[wj==23,AppendTo[Ds,1],AppendTo[Phis,1]];
ASites=Dropp[ASites,1];
];

If[fullout,
(*AppendTo[out2,{ITER,Einit,t,dCharge[[wj]],dt,Ds,Phis,NN,m,Length[Ds]+m,totrates,wj,wc,Zener[wj,wc]}];*)
AppendTo[out2,{NN,m,wj,wc,dCharge[[wj]],Zener[wj,wc],Ds,Phis,totrates}];
,
Ess=sectors[Es[1]][[2]];
Ess=Ess-Ess[[1]];
AppendTo[out2,{NN,m,dCharge[[wj]],Zener[wj,wc],Table[Sum[totrates[[x]],{x,X}],{X,RateTypeInds}],totrates[[25;;26]],wj,wc,Ess}];
];


If[debug,
Print["t = ",t];
Print["N,m: ",{NN,m}];
Print["Ds: ",Ds];
Print["\[Phi]s: ",Phis];
Print["Einit: ",Einit];
];
];
If[printmem,
Print["After: MemoryInUse (MB)",MemoryInUse[]/10^6//IntegerPart];
Print["Dimensions of eigensystems:",Table[Dimensions[Es[p]],{p,1,13}]
];
];

out2
];

Complement
(*X={Ntot,gg,maxiter,
initstate,
tpar,kappa,gamma,
dw,Eb,Er,w0,beta,
includecross,BlockInjection,AlwaysLP,
VibAssis,M,wv,lambda};
Table[x\[Rule] OptionValue[x],{x,X}]*)

Options[Trajectory]={Ntot-> 5,m0-> 1,Ds0-> {},Phis0-> {},g-> 1,dw-> 0,tpar-> {0.1,0.001,0.001,0.05,0.01,0.01,0.01,0.01},Eb-> {0,0},kappa-> 0.005,gamma-> 0.005,Er-> 0.5,w0->2,beta-> 40,maxiter-> 20,includecross-> True,BlockInjection->{ False,False},M-> 3,wv->0.2 ,lambda-> 1,AlwaysLP-> True,VibAssis-> False,printmem-> False,fullout-> False,staylow-> True};

Trajectory[OptionsPattern[]]:=
CalcTrajectory[OptionValue[Ntot],OptionValue[m0],OptionValue[g],OptionValue[maxiter],OptionValue[Ds0],OptionValue[Phis0],OptionValue[tpar],OptionValue[kappa],OptionValue[gamma],OptionValue[dw],OptionValue[Eb],OptionValue[Er],OptionValue[w0],OptionValue[beta],OptionValue[includecross],OptionValue[BlockInjection],OptionValue[AlwaysLP],OptionValue[VibAssis],OptionValue[M],OptionValue[wv],OptionValue[lambda],OptionValue[printmem],OptionValue[fullout],OptionValue[staylow]];

