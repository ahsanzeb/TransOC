(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)




(* mapHtApairs: for Apairs that can make D & Phi: start with final basis combination and add two sites at appropriate positions in the list of active sites with one being up and other down, and calc index for initial state *)

mapHtApairsc[N_,k_,sapos_]:=Module[
{n1,n2,x1,x2,listi1,listi2,tab1,tab2,set1,set2,listf1,listf2,set11,set12}
,
{n1,n2}=sapos;
tab1={};tab2={};
(* (N-2,k-1), add desired up/dn or dn/up to make (N,k) *)
(* exclude k=0 case *)
If[k>0,
listi1=comb[N-2,k-1]; 
Do[
set1=listi1[[i]];
(* add an up site at n1 position
and a down at n2 position; shift n1+ and n2+ labels by 1 or 2 as they should be *)
(* shift by +1 twice for second case means +2 total as desired *)
set11=set1/.{q_Integer/;q>= n1->q+1};
set12=set11/.{q_Integer/;q>= n2->q+1};
(* Adding up/down  at n1/n2*)
listf1=Sort[Join[set12,{n1}]];
(* Adding down/up  at n1/n2*)
listf2=Sort[Join[set12,{n2}]];
(* indices for (N,k) case *)
x1=c[N,k]-Sum[c[N-listf1[[p+1]],k-p],{p,0,k-1}];
x2=c[N,k]-Sum[c[N-listf2[[p+1]],k-p],{p,0,k-1}];
AppendTo[tab1,x1];
AppendTo[tab2,x2];
,{i,1,Length[listi1]}];
];
{tab1,tab2}
];



mapHtApairsclh[N_,k_,sapos_]:=Module[
{n1,n2,x1,listi1,tab1,set1,listf1,set11,set12}
,
{n1,n2}=sapos;
tab1={};
(* (N-2,k-1), add desired up/dn or dn/up to make (N,k) *)
(* exclude k=0 case *)
If[k>1,
listi1=comb[N-2,k-2]; 
Do[
set1=listi1[[i]];
(* add an up site at n1 position
and a down at n2 position; shift n1+ and n2+ labels by 1 or 2 as they should be *)
(* shift by +1 twice for second case means +2 total as desired *)
set11=set1/.{q_Integer/;q>= n1->q+1};
set12=set11/.{q_Integer/;q>= n2->q+1};
(* Adding up,up  at n1,n2*)
listf1=Sort[Join[set12,{n1,n2}]];(* both up: tlh, k--> k-2*)
x1=c[N,k]-Sum[c[N-listf1[[p+1]],k-p],{p,0,k-1}];
AppendTo[tab1,x1];
,{i,1,Length[listi1]}];
];
tab1
];


mapHtApairschl[N_,k_,sapos_]:=Module[
{n1,n2,x1,listi1,tab1,set1,listf1,set11,set12}
,
{n1,n2}=sapos;
tab1={};
(* (N-2,k-1), add desired up/dn or dn/up to make (N,k) *)
(* exclude k=0 case *)
If[k>1,
listi1=comb[N-2,k]; 
Do[
set1=listi1[[i]];
(* add an up site at n1 position
and a down at n2 position; shift n1+ and n2+ labels by 1 or 2 as they should be *)
(* shift by +1 twice for second case means +2 total as desired *)
set11=set1/.{q_Integer/;q>= n1->q+1};
set12=set11/.{q_Integer/;q>= n2->q+1};
(* dn,dn at n1,n2*)
x1=c[N,k]-Sum[c[N-set12[[p+1]],k-p],{p,0,k-1}];
AppendTo[tab1,x1];
,{i,1,Length[listi1]}];
];
tab1
];



makeHtApairsc[N_,m_,sapos_]:=Module[
{pntr0,pntr1,ntot0,Hta,Htb,coora,coorb,ntot1,tab1,tab2,ind1,ind01,ind02,t1,t2,Htsph,Htspl,m1,m2,m3},
(* v v importnat: in  sapos, n2>n1 *)
(* pointers for start index *)
m1=Min[m,N];m2=Min[m-1,N-2];m3=Min[m,N-1];(* m3=> a dn is also needed so all up excludeed in the loop below*)
pntr0=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
pntr1=Insert[Table[Sum[c[N-2,j],{j,0,i}],{i,0,m2}],0,1];
ntot0=pntr0[[-1]];
ntot1=pntr1[[-1]];
Hta={};Htb={};
(* k loop up to m3=Min[m,N-1] so that 
there is always a down spin available for non-empty map;
starts from 1, so for an up spin available *)
Do[
(* indices list of initial states *)
{tab1,tab2}=mapHtApairsc[N,k,sapos];
ind01={pntr0[[k+1]]+tab1}//Transpose;
ind02={pntr0[[k+1]]+tab2}//Transpose;
ind1={pntr1[[k]]+Table[i,{i,1,c[N-2,k-1]}]}//Transpose;
If[Length[tab1]>0,coora=Join[ind01,ind1,2];AppendTo[Hta,coora ];];
If[Length[tab2]>0,coorb=Join[ind02,ind1,2];AppendTo[Htb,coorb ];];
,{k,1,m3}];
Htsph=SparseArray[Flatten[Hta,1]-> 1,{ntot0,ntot1}];
Htspl=SparseArray[Flatten[Htb,1]-> 1,{ntot0,ntot1}]; 
{Htsph,Htspl}
];

makeHtApairsclh[N_,m_,sapos_]:=Module[
{pntr0,pntr1,ntot0,Hta,coora,ntot1,tab,ind1,ind01,Htsplh,m1,m2,m3},
(* v v importnat: in  sapos, n2>n1 *)
(* pointers for start index *)
m1=Min[m,N];m2=Min[m-2,N-2];
pntr0=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
pntr1=Insert[Table[Sum[c[N-2,j],{j,0,i}],{i,0,m2}],0,1];
ntot0=pntr0[[-1]];
ntot1=pntr1[[-1]];
Hta={};
Do[
(* indices list of initial states *)
tab=mapHtApairsclh[N,k,sapos];
If[Length[tab]>0,
ind01={pntr0[[k+1]]+tab}//Transpose;
ind1={pntr1[[k-1]]+Table[i,{i,1,c[N-2,k-2]}]}//Transpose;coora=Join[ind01,ind1,2];AppendTo[Hta,coora ];
];
,{k,2,m1}];
Htsplh=SparseArray[Flatten[Hta,1]-> 1,{ntot0,ntot1}];
Htsplh
];

makeHtApairschl[N_,m_,sapos_]:=Module[
{pntr0,pntr1,ntot0,Hta,coora,ntot1,tab,ind1,ind01,Htsphl,m1,m2,m3},
(* v v importnat: in  sapos, n2>n1 *)
(* pointers for start index *)
m1=Min[m,N];m2=Min[m,N-2];m3=Min[m,N-2];
pntr0=Insert[Table[Sum[c[N,j],{j,0,i}],{i,0,m1}],0,1];
pntr1=Insert[Table[Sum[c[N-2,j],{j,0,i}],{i,0,m2}],0,1];
ntot0=pntr0[[-1]];
ntot1=pntr1[[-1]];
Hta={};
Do[
(* indices list of initial states *)
tab=mapHtApairschl[N,k,sapos];
If[Length[tab]>0,
ind01={pntr0[[k+1]]+tab}//Transpose;
ind1={pntr1[[k+1]]+Table[i,{i,1,c[N-2,k]}]}//Transpose;coora=Join[ind01,ind1,2];AppendTo[Hta,coora ];
];
,{k,0,m3}];
Htsphl=SparseArray[Flatten[Hta,1]-> 1,{ntot0,ntot1}];
Htsphl
];


